<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zr的博客</title>
  
  <subtitle>向死而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiankafei.github.io/"/>
  <updated>2017-11-21T04:45:54.608Z</updated>
  <id>https://jiankafei.github.io/</id>
  
  <author>
    <name>王勒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web全链路优化</title>
    <link href="https://jiankafei.github.io/web/Full%20link%20optimization%20at%20the%20front%20end/"/>
    <id>https://jiankafei.github.io/web/Full link optimization at the front end/</id>
    <published>2017-11-21T03:52:15.000Z</published>
    <updated>2017-11-21T04:45:54.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从访问一个页面到页面的呈现，要经历以下的过程：<br>DNS查询-TCP连接 &gt; 客户端http请求 &gt; 服务端响应 &gt; 客户端渲染<br>下面就从整个过程分析下有哪些可以优化的地方和措施。</p><a id="more"></a><h2 id="DNS查询优化："><a href="#DNS查询优化：" class="headerlink" title="DNS查询优化："></a>DNS查询优化：</h2><p>client &gt; os &gt; hosts &gt; os发起DNS请求</p><p>DNS查询总是要经过上述过程的，不可避免。<br>可以优化的地方是前端的 DNS-Prefetch 链接预取。在页面的head头部加入：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样可以预查询DNS和预加载资源到缓存。</p><h2 id="请求速度优化："><a href="#请求速度优化：" class="headerlink" title="请求速度优化："></a>请求速度优化：</h2><h3 id="资源优化："><a href="#资源优化：" class="headerlink" title="资源优化："></a>资源优化：</h3><ol><li>对同一个域名的同类资源进行请求合并，减少http请求数，需要后端支持；</li><li>对资源进行压缩及合并处理，如果可以的话；</li><li>如果一次性加载的资源少，尽量使用一个cdn，如果加载的资源非常多，则可以启用多个cdn域名，从而突破前端连接数限制；</li><li>资源按需加载，比如在 SPA 单页应用中，如果单页应用比较大，就不要一次性加载全部资源和页面，而应该按需异步加载访问的页面组件。webpack提供了 Code Splitting 代码分割功能，Vue就使用该功能实现异步组件；</li></ol><h3 id="http协议选择："><a href="#http协议选择：" class="headerlink" title="http协议选择："></a>http协议选择：</h3><p>各大浏览器厂商都已经支持 http2了，如果可以，尽量启用 http2。http2 有很多优点：</p><ol><li>服务端推送，可以缓存；</li><li>多路复用：单连接并发多请求。基于流的实现；</li><li>头部压缩：使用 HPACK 算法压缩头部；</li><li>请求优先级和依赖性：优先级高的需要首先处理，优先级低的可以稍微排排队；</li><li>二进制文件，解析更有效率，更紧密，更不容易出错；</li></ol><h2 id="渲染优化："><a href="#渲染优化：" class="headerlink" title="渲染优化："></a>渲染优化：</h2><h3 id="script优化："><a href="#script优化：" class="headerlink" title="script优化："></a>script优化：</h3><ol><li>script标签放到body闭合标签前面，不阻塞页面渲染，加快页面显示；</li><li>永远只在必要的情况下使用框架和库，如果业务很小但是用了较大的库，即使是 jQuery 也是得不偿失的；</li><li>能异步加载和延迟加载的script就异步和延迟加载，比如统计代码；</li></ol><h3 id="css优化："><a href="#css优化：" class="headerlink" title="css优化："></a>css优化：</h3><ol><li>删除无用规则和重复规则；</li><li>可以考虑内联关键CSS；</li><li>避免@imports和Base64；<br>避免 Bas64 可以提高css文件的压缩比率；甚至在任何文件里都应该避免使用 Base64；</li><li>尽量少的使用耗性能的 css 属性和选择器，比如 * 通配符，从而加快CSSOM构建和渲染。css优化细节挺多的，这里不细说；</li><li>style标签放到head标签，防止页面的跳动渲染；</li></ol><h3 id="image优化："><a href="#image优化：" class="headerlink" title="image优化："></a>image优化：</h3><ol><li>尽量使用压缩比率高的格式，比如 webp；</li><li>对于图标，尽量使用svg或者iconfont字体图标。也可以使用兼容性较好的 css sprite；</li><li>尽量不要包含太多的 Base64 格式的图片，会降低文件压缩率；</li><li><p>如果页面有大量图片，建议做图片延迟加载和预加载；<br>在分页业务里，可以考虑使用图片预加载。<br>在一次性展示大量图片的页面里，可以考虑使用延迟加载。</p><p>注：更具体的图片优化，可以看这篇文章：<a href="http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html" target="_blank" rel="noopener">图片优化</a></p></li></ol><h3 id="html优化："><a href="#html优化：" class="headerlink" title="html优化："></a>html优化：</h3><ol><li>尽量使用语义化标签，提高SEO优化；</li><li>对于不支持h5标签的浏览器采用html5.shim.js来支持；</li><li>标签不要嵌套过深；</li><li>对于移动端的响应式布局和高清显式，可以看我的原创项目<a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible</a>，该项目在生产环境下经历了多个版本，目前已经很稳定了，具体可以查看项目。</li></ol><h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><ol><li>避免不必要的重定向；</li><li>可以适当提高最大连接数，加快资源响应；</li><li>使用内容分发网络 CDN ，加快资源响应；</li><li>适当调节CDN的TTL值，增加缓存时间，提高缓存命中率；</li><li>开启 gzip 压缩；</li></ol><h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><ol><li>Last-Modified: 能初步检测文件是否更改，没更改则返回304，但是 Last-Modified 也有它自己的缺点，比如文件内容没改变，只是最后修改时间改变，还有它的检测时间是秒级的，还有它不能精确得到文件的最后修改时间，这些问题都会导致问题；</li><li>ETag：ETag可以解决Last-Modified的问题，ETag是内容相关的。所有把两者放在一起，可以很好的做到缓存优化；</li><li>Cache-Control: 用于代替 Expires，对于某些只需要在一定时间之后过期的资源来说，使用它最合适了；</li></ol><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><ol><li>服务端的其他优化，比如负载均衡等，由于尚不了解，这里就不说了；</li><li>数据库也不甚了解，这里也不说了；</li><li>哪里说的不对，可以提issue交流；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从访问一个页面到页面的呈现，要经历以下的过程：&lt;br&gt;DNS查询-TCP连接 &amp;gt; 客户端http请求 &amp;gt; 服务端响应 &amp;gt; 客户端渲染&lt;br&gt;下面就从整个过程分析下有哪些可以优化的地方和措施。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://jiankafei.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://jiankafei.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>flex布局解析</title>
    <link href="https://jiankafei.github.io/css/flexLayout/"/>
    <id>https://jiankafei.github.io/css/flexLayout/</id>
    <published>2016-08-12T00:15:29.000Z</published>
    <updated>2017-04-10T10:42:44.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。<br><a id="more"></a></p><h2 id="看法"><a href="#看法" class="headerlink" title="看法"></a>看法</h2><p>这里我只说说最新版本，在我看来，学习即将不再使用的东西是对时间和精力的浪费(个人观点，不喜勿喷)，旧的东西大家如果想了解可以度娘。虽然我不说旧版本，但我还是会给出完整的兼容实现。具体见我的这个项目<a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible</a>的flexbox.css。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="flexbox盒模型"><a href="#flexbox盒模型" class="headerlink" title="flexbox盒模型"></a>flexbox盒模型</h3><p>该盒模型，你只需知道有主轴和侧轴之分就行，没有横轴和竖轴或者水平和垂直之说。<br>那怎么区分主轴和侧轴呢，见下方。</p><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><p>一句话，该属性设置的方向就是主轴，和主轴垂直的方向那就是侧轴了。<br>这里需要说一点，就是每一个轴都有两个方向。默认从左到右，从上到下，标准的坐标系。<br>现在主轴和侧轴都确定了，但如果内容比较多，你想让它换行，怎么办呢，不急，看下面。</p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap：nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure><p>该属性就是 flex 盒模型里的换行属性。三个值我就不解释了，自己查单词去。<br>既然有了换行，那就说明会有多行，如果有个场景需要让多行的元素块在定高的盒子里上下居中，怎么办呢，很显然这说的时对齐方式了。看下面。</p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>主轴对齐方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content：flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure></p><p>这个真没什么可解释的</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>侧轴对齐方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content：flex-start | flex-end | center | space-between | space-around | stretch</span><br></pre></td></tr></table></figure></p><p>这里唯一需要说的就是 stretch<br>stretch 的作用是，在侧轴间距上，将各行均匀伸展来撑满真个侧轴间距。具体分两种情况。<br>如果剩余的空间是负数，该值等效于’flex-start’；<br>在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。</p><p>在侧轴的对齐上，align-content 只解决了把侧轴里多行看成整体在盒子内的对齐；<br>而侧轴里的每一行上元素的高度不一定是一致的，有的高有的低，该行的行高肯定就是最高元素的高度了。这里我们称为行内轴，有些场景就需要在一行里这些元素是如何对齐的，也就是在行内轴上是如何对齐的，这有点像 vertical-align（只是有点像，不要混为一谈）。是在本行内开始位置对齐，还是中部对齐，还是结束对齐等等（由flex-direction决定哪里是开始位置）</p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items：flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure><p>这里说下 baseline<br>    如果弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</p><p>还有 stretch<br>    会遵照’min/max-width/height’属性的限制</p><p>到现在，侧轴和行内轴的对齐都解决了，但有些人说行内轴对齐好了，但我想让一行中的某一个元素的对齐方式和其他的元素不一样，该怎么办呢，看下面。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self：auto | flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure><p>这个属性的值和上一个的一模一样，是对行内轴对齐方式的复写，但是只应用在子元素上，从而单独复写对齐方式。</p><p>ok，现在换行，对齐，子元素单独对齐都好了，那为什么还叫伸缩盒模型呢，那是因为下面。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>这个属性其实是个简写属性，具体是 flex-grow flex-shrink flex-basis 的简写属性</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>扩展比率，默认 0<br>没什么可说的，就是个数学问题</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>收缩比率，不允许负值，默认 1<br>没什么可说的，就是个数学问题</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | &lt;percentage&gt; | auto | content</span><br></pre></td></tr></table></figure><p>基准宽度，就是说在此宽度的基础上扩展或收缩宽度<br>这里说下 auto： 无特定宽度值，取决于其它属性值<br>还有 content：基于内容自动计算宽度</p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>和它的名字一样，掌管盒子内子元素的流动，就和水一样，流向哪个方向，遇到石头是冲过去还是拐弯，都是这个属性的事情。<br>废话不说了，该属性也是个简写属性，是 flex-direction 和 flex-wrap 的简写属性。没了。</p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>记得小时候每次开学，都会有一次排队选座位的经历，老师显然大家自觉排好，然后老师再仔细看一遍，把没排好同学互换过来，然后分座位。排队很简单，错了可以再排，但如果时html元素呢，如果我们把元素的顺序都写好了， 在没有定位，浮动，js操作的情况下，元素肯定是按顺序排列的，如果我们想互换元素之间的顺序，是做不到的。那如果有这样的需求怎么办呢。这就要order上场了，首先 display: flex 搭好台子，order就可以表演了。通过对flex子元素设置order属性，可以改变元素原来的显示顺序。当然它也受 flex-direction 的影响。<br>具体规则是：<br>用整数值来定义排列顺序，数值小的排在前面。可以为负值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://jiankafei.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jiankafei.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端web高清屏显示及伸缩布局方案(原创)</title>
    <link href="https://jiankafei.github.io/js/flexible/"/>
    <id>https://jiankafei.github.io/js/flexible/</id>
    <published>2016-08-11T02:41:29.000Z</published>
    <updated>2017-11-21T04:25:00.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统；</p><a id="more"></a><p>这个方案我是在网上看了关于 viewport 缩放页面后，结合当前使用的rem布局方案而来。<br>你有没有在移动H5开发的时候遇到过这样的情况，页面不清晰，明明1px的线条看上去却很宽，而且有些模糊，图片看上去好像失真了一样？和大厂的m站一比，光看自己页面的细节就土的掉渣。遇到过，那就说明你用的移动设备的屏幕是高清屏，也就是dpr大于1的屏幕。而这一切都是拜 乔帮主(你知道是哪位) 所赐。我这里只是简单的介绍，本来也想详细的说说，但感觉自己的语言组织不是太给力，所以还是推荐大家直接看参考文章，这些文章都很值得大家好好看的，里面图文并茂，该有的不该有的都有。</p><h2 id="传统的一种移动端布局方案"><a href="#传统的一种移动端布局方案" class="headerlink" title="传统的一种移动端布局方案"></a>传统的一种移动端布局方案</h2><p>w: 当前页面宽度<br>x: 当前字体大小</p><p>换算关系:<br>w / 640 = x / 100</p><p>所有的px尺寸都除以100，就得到rem的尺寸</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><pre><code>border: 1px问题;图片高清问题;屏幕适配布局问题;</code></pre><h2 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h2><h3 id="设备像素比dpr"><a href="#设备像素比dpr" class="headerlink" title="设备像素比dpr"></a>设备像素比dpr</h3><pre><code>dpr = 物理像素 / 设备独立像素;</code></pre><p>参考文章：<br><a href="http://www.zhangxinxu.com/wordpress/?p=2568" target="_blank" rel="noopener">设备像素比devicePixelRatio简单介绍</a><br><a href="http://sentsin.com/web/1212.html" target="_blank" rel="noopener">原创移动端高清、多屏适配方案</a></p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>关于flex布局可以看下我的这篇文章：<a href="https://jiankafei.github.io/css/flexLayout/">flex布局解析</a></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="flex解决布局适配问题"><a href="#flex解决布局适配问题" class="headerlink" title="flex解决布局适配问题"></a>flex解决布局适配问题</h3><p>参见 <a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible项目</a> 的flexible.css</p><h3 id="动态修改meta标签实现页面的缩放"><a href="#动态修改meta标签实现页面的缩放" class="headerlink" title="动态修改meta标签实现页面的缩放"></a>动态修改meta标签实现页面的缩放</h3><p>参见 <a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible项目</a> 的flexible.js</p><h3 id="高清图片"><a href="#高清图片" class="headerlink" title="高清图片"></a>高清图片</h3><h4 id="SVG-图标系统"><a href="#SVG-图标系统" class="headerlink" title="SVG 图标系统"></a>SVG 图标系统</h4><p>可以解决小icon的高清适配问题，因为SVG是矢量图，缩放不会失真;<br>建议通过 <a href="http://www.iconfont.cn/plus" target="_blank" rel="noopener">iconfont</a> 制作<br>这里有一个在线的 <a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="noopener">svg压缩工具</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 定义 */</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">symbol</span> <span class="attr">id</span>=<span class="string">"icon"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 200 200"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>opt<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* 使用 */</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h4><p>可以解决 <code>icon</code> 的高清适配问题，建议通过 <a href="http://www.iconfont.cn/plus" target="_blank" rel="noopener">iconfont</a> 制作</p><h4 id="MediaQuery"><a href="#MediaQuery" class="headerlink" title="MediaQuery"></a>MediaQuery</h4><p><code>MediaQuery</code> 可以解决背景图片的高清适配;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen</span><br><span class="line">and (-webkit-device-pixel-ratio:<span class="number">2</span>)</span><br><span class="line">and (-webkit-min-device-pixel-ratio:<span class="number">1.5</span>)</span><br><span class="line">and (-webkit-max-device-pixel-ratio:<span class="number">2.5</span>)&#123;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(<span class="selector-tag">icon_2</span>@.<span class="keyword">png</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CSS的image-set属性"><a href="#CSS的image-set属性" class="headerlink" title="CSS的image-set属性"></a>CSS的image-set属性</h4><p>image-set属性可以解决背景图片的高清适配;<br>目前移动端可以使用带 -webkit- 前缀的属性，Android4.4及以上系统，IOS9.0及以上系统;<br>可在 <a href="http://www.caniuse.com/#search=image-set" target="_blank" rel="noopener">caniuse</a> 查看该属性目前的支持情况;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="comment">/* 不支持image-set的浏览器 */</span></span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(icon_1@.png) no-repeat;</span><br><span class="line"><span class="comment">/* 支持image-set的浏览器 */</span></span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-image-set</span>(</span><br><span class="line">url(icon_1@.png) <span class="number">1</span>x, <span class="comment">/* 普通屏 */</span></span><br><span class="line"><span class="built_in">url</span>(icon_2@.png) <span class="number">2</span>x <span class="comment">/* 高清屏 */</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片延迟加载"><a href="#图片延迟加载" class="headerlink" title="图片延迟加载"></a>图片延迟加载</h4><p>移动端的图片延迟加载在我看来很必要的，而且顺带可以解决图片的高清适配;<br>通过 <code>window.devicePixelRatio</code> 可以获取到当前设备的dpr，然后加载相应的图片。</p><h4 id="img的srcset和sizes属性"><a href="#img的srcset和sizes属性" class="headerlink" title="img的srcset和sizes属性"></a>img的srcset和sizes属性</h4><p><img src="" srcset="" sizes=""><br>解决图片的高清适配，具体还是看<a href="http://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/" target="_blank" rel="noopener">张鑫旭张老师的这篇文章</a></p><p>转载请注明出处：<a href="https://jiankafei.github.io/js/flexible/">移动端web高清屏显示及伸缩布局方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统；&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiankafei.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jiankafei.github.io/tags/js/"/>
    
  </entry>
  
</feed>
