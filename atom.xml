<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zr的博客</title>
  
  <subtitle>向死而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiankafei.github.io/"/>
  <updated>2017-12-08T13:07:02.801Z</updated>
  <id>https://jiankafei.github.io/</id>
  
  <author>
    <name>王勒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS要点解析</title>
    <link href="https://jiankafei.github.io/JS/js-key-points/"/>
    <id>https://jiankafei.github.io/JS/js-key-points/</id>
    <published>2017-12-04T09:17:19.000Z</published>
    <updated>2017-12-08T13:07:02.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对JS学习过程中的一些理解和总结</p><a id="more"></a><p>从我工作到 2017/10 辞职，总共两年时间，期间一直想写个总结JS的文章，却一直没下决心动手，这次，借着辞职学习的时间，把这件事办了。也算是给自己一个交代。</p><p>对于前端开发来说，JS的确是一门很有魔力的语言。它不需要静态类型语言对变量类型的严格要求，也不需要编译型语言需要编译才能真正执行（期间，学习了Go语言，真的很喜欢Go语言，也终于让我有理由学习后端开发了。虽然Node也可以，但使用JS写Node服务，真的不太舒服，后端还是需要静态类型语言来做才最合适），这让它在Web前端风生水起（我看过Dart的语法，出自Google，如Go般简洁，前端后端都有支持，很希望Dart能替代JS，但是看现在的情况是不可能了）。</p><p>C语言等类C的静态编译型语言里面，程序要想执行，都会有一个入口函数main。但JS在html里面通过script的方式加载，script分割代码的分割问题，以及JS加载都是通过script为单位进行编译（JS的编译好像只有词法分析和语法分析）和执行的问题，致使js在标准上写不了main入口函数，所以JS提供了全局作用域这么个东西。相当于JS线程自己就有个main函数在跑一样。</p><p>说到函数执行，这里就有几点需要提了。</p><p>JS函数传参调用的方式：<br>传名调用 or 传值调用：<br>JS是传值调用的，对于初学JS的小白来说，这让他们很矛盾。因为他们知道JS有基本类型，有引用类型。引用类型当作参数传入函数调用，如果按传值调用，引用类型传入的又是什么呢？传入的是引用类型的指针，又称内存地址，在JS里统一叫引用，也就是说JS不会把引用类型传过去（真传过去了，就是另一个对象了），而是把地址当作值传过去。</p><p>这里要说的一点是，JS函数传参后，arguments 和形参的关系：<br>如果函数调用时，相应的位置传入了实参，那么 arguments 和形参是互相影响的，也就是说，修改了一个，另一个也会相应的更改，并且是严格相等的。如果相应位置没有传入实参，则他们 arguments 和形参之间是互相独立的。至少在chrome上测试是这样的。</p><p>JS在执行之前，也就是词法分析和语法分析之后，还有一个预解析，预解析做的事就是先提升var声明的变量，初始值为undefined，再提升function声明的函数（直接提升整个函数体）。其实可以这么理解，var和function提升的是变量的创建和初始化，只不过var的变量的初始值为undefined。let const class 等提升的是创建，但并没有提升初始化，而变量只有在初始化之后才可以使用，可以解释了let const 形成的暂时性死区，而且const 没有赋值操作。</p><p>该轮到函数执行了。在JS主线程的函数执行会形成一个执行栈，函数里定义的变量就都在栈内存里存放着，基本类型保存的就是真实的基本类型的值，引用类型保存的就是引用类型的地址，而引用类型们都在堆内存里存放着。栈内存里变量的存放是有次序和有固定大小的，这也是为什么基本类型string boolean number 的值是不可更改的原因，如果有新值都是另外开辟新的内存来存放新值，至于引擎对基本类型的优化，应该就挺底层的了，我们也不要太过关注。堆内存里对象的存放都是没有结构次序，任意存放的，大小不固定的，所以可以修改对象的属性。</p><p>函数的执行链是个后入先出的过程，函数执行完毕后，它的执行栈会被弹出，也就是销毁，栈都没了，里面存放的变量自然就释放了。而堆内存里的引用类型们可不会因为函数执行完毕而销毁，它们会等待GC来回收他们。</p><p>GC回收引用类型，我知道的有两种方式，为了少些文字，我把引用类型在之后都叫做对象：</p><ol><li>引用计数：会标记变量或属性对对象的引用个数，如果引用个数为0，就是说它不在被使用，那将会在下一次垃圾回收中回收。但引用计数有循环引用的问题，导致对象无法被回收，A和B互相引用，但它们都没有被其他变量所引用，理应回收他们，计数方式就不能解决这个问题。</li></ol><p>代表有，IE8-的浏览器，这个比较特殊，IE8-的JS引擎用的是标记清除，但IE8-浏览器提供的DOM和BOMd对象是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制使用的是引用计数，导致如果循环引用中存在COM对象，就会出现上述问题，IE9把COM对象变成了真正的JS对象，这个问题才得以解决。（出自JavaScript高级程序设计）</p><ol><li>标记清除：现代的浏览器大都使用这种方式回收垃圾。它的策略是这样的：</li></ol><p>标记阶段，从全局变量对象（根对象）向下遍历，对能从根对象访问到的对象，都添加标记，这些对象称为可达对象。</p><p>清除阶段，遍历堆内存，如果某个对象是可达对象，则清除标记，为下一次标记做准备，不可达对象直接回收内存。具体可以看这篇<a href="http://www.jianshu.com/p/b0f5d21fe031" target="_blank" rel="noopener">文章</a></p><p>接下来说下函数执行形成的作用域链：<br>JS的全局作用域会生成一个全局变量对象，用来保存全局作用域内的变量，该对象很显然只会在页面关闭的时候才会销毁，因为这些变量会在之后的程序执行中被用到。</p><p>函数的定义：<br>引擎为函数添加 [[scopechain]] 属性，该属性为它当前所处位置的作用域链。如果获得这个链条，后面会说。</p><p>JS函数在执行的时候，会创建一个 {excution context} 执行环境对象，就是该对象决定了函数调用时候的this值(call, apply, bind 会改变this)。在创建该对象的时候，还会做以下几件事：</p><ol><li>为函数添加 [[scope]] 属性，值为 scopechain</li><li>创建执行时的活动对象 {activation object} ，活动对象里有 arguments this 命名参数 变量对象。</li><li>把 {activation object} 添加到 [[scope]] 属性的顶部，也就是第一个。</li><li>当执行完毕，释放[[scope]]，回收 {excution context]} {activation object}</li></ol><p>可以看出，函数在执行的时候，都有自己的作用域链属性。而且作用域链就是个活动对象数组（具体什么结构，我也不知道，也许是集合呢）。但函数定义在什么地方是写死的，所以函数的 scopechain 永远是不会变的。这就是为什么叫做词法作用域。</p><p>这里做两个作用域链的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">d();</span><br><span class="line">&#125;;</span><br><span class="line">c();</span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 a.scopeChain = [window]</span></span><br><span class="line"><span class="comment">//执行 a.scope = [a, ...a.scopeChain]</span></span><br><span class="line"><span class="comment">//定义 b.scopeChain = a.scope</span></span><br><span class="line"><span class="comment">//执行 b.scope = [b, ...b.scopeChain]</span></span><br><span class="line"><span class="comment">//定义 c.scopeChain = b.scope</span></span><br><span class="line"><span class="comment">//执行 c.scope = [c, ...c.scopeChain]</span></span><br><span class="line"><span class="comment">//定义 d.scopeChain = c.scope</span></span><br><span class="line"><span class="comment">//执行 d.scope = [d, ...d.scopeChain]</span></span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">a()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">c()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 a.scopeChain = [window]</span></span><br><span class="line"><span class="comment">//定义 b.scopeChain = [window]</span></span><br><span class="line"><span class="comment">//定义 c.scopeChain = [window]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 a.scope = [a, ...a.scopeChain];</span></span><br><span class="line"><span class="comment">//执行 b.scope = [b, ...b.scopeChain];</span></span><br><span class="line"><span class="comment">//执行 c.scope = [c, ...c.scopeChain];</span></span><br></pre></td></tr></table></figure><p>等号右侧：</p><ol><li>window 指代得到是全局变量对象</li><li>a, b, c, d 指的是函数各自在执行时生成的活动对象</li></ol><p>到了该说闭包的时候了，成气候了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> qq = <span class="number">11</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(qq);</span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> qq = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(qq);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a();</span><br></pre></td></tr></table></figure></p><p>闭包我这里想说个自己定义的概念，广义闭包，狭义闭包（爱因斯坦会不会打我）。</p><p>广义闭包就是函数内部没有使用外部作用域的变量的函数，或者使用了外部变量，但函数只在作用域内部使用的函数。</p><p>狭义闭包相反，狭义闭包就是我们常被问到必挂在嘴边的闭包。</p><p>第一种闭包是广义闭包，由于还是在父作用域体内，等a函数执行完毕，闭包离开执行环境，就会被回收；</p><p>第二种就是比较典型的狭义闭包，a内部的匿名函数形成闭包，并传递给b变量，如果a函数是在全局作用域，在不关闭页面的情况下只有把b赋值为null，解除引用，闭包才会被回收。如果a函数是在另一个函数体内，那么等这个父函数执行完毕，b离开执行环境，标记清除就会回收b引用的闭包。现代浏览器都比较智能，这一点基本可以放心，如果不放心，那就手动赋值为null吧。</p><p>上面说了闭包的产生和销毁，现在就来说说，我们整天念叨的闭包到底指的是什么。它又是和什么有关系的。</p><p>在之前我们已经说了函数定义和调用阶段所做的事。闭包就是和他们有关系。不管是函数定义上的 scopechain 还是执行时的 scope，它们都引用了祖辈函数执行的活动对象。广义闭包由于定义的函数在其父函数执行完毕后，就销毁了，所以不会一直保留对所有祖辈活动对象的引用。而狭义闭包，按理说函数执行完毕，内部定义的所有变量和函数都是要别回收的，但问题是如果把一个函数当成返回值返回了，返回之后还赋给一个变量，相当于这个函数在它的父函数执行完毕后理应销毁的情况下，并没有销毁，那么该函数身上的 scopechain 引用的活动对象也就不会释放，这就是闭包的根源，在外部引用了内部的函数，导致理应销毁的活动对象没有被销毁。</p><p>闭包说完了，该说说我们在前面提到的 {excution context} 执行环境对象，也叫执行上下文对象。这个对象是谁呢？有一个技巧，就是函数是以谁的方法的身份执行的，那么这个对象就是谁，this就是谁。this的确定就这么简单。在严格模式下，由于var function 声明的变量和函数默认不再挂载到window上。所以函数的直接执行，并没有作为任何对象的方法的身份来执行，所以this为undefined也是说的通的。</p><p>函数重载的概念其实不是JS的。JS在理论上或者语法上没有这个概念。这个概念一般存在于传统的静态类型语言里。由于静态类型语言在定义函数时，函数的形参的类型都是需要确定的，所以如果同一个函数在调用的时候，如果有传入不同类型或者个数的参数都能处理的需求，那就需要函数重载，重载根据传入的参数的类型和数量的不同实现签名，特定的传参调用会调用特定的签名函数。反观JS，JS的函数也是对象，同一函数名在同一作用域下只能有一个，后面的会覆盖前面的，同一变量不可能指向多个地址。所以重载不可能，但JS也有办法处理这种需求，那就是函数的 arguments 对象 和 最新的 rest 参数。拿arguments来说，它是一个集合，里面包含了所有传入的参数，我们可以通过判断 arguments.length 和 arguments 中的每一项的类型来做不同的操作，同样也实现了这种需求。</p><p>下面来说说对象：</p><p>首先要说的就是对象的引用。JS对于引用类型的处理非常高名，而这一处理方式也带来了很多其他的概念名词：浅拷贝，变量是否改变。</p><p>刚学JS时我很在意浅拷贝这个概念，但没过多久，我就觉得这对JS来说就是个伪概念，而且现在还非常盛行。js所有的引用类型都是在堆内存里面，他们都是独立的，并不是我们表面上看到的，一个嵌套一个，他们的属性存放的都是值，如果本身的值为引用类型，那么这个值就是引用类型的地址。所以可以认为，在存储机制方面，js对象都是扁平化的。我自己想了这么个词，不同意的可以提issue交流。</p><p>对象里最重要的当属原型和原型链了。原型是什么，原型就是个普通对象。原型链是什么，原型链用于属性查找（函数的作用域链用于变量查找），自身没有的属性沿着原型链一直往上找，直至找到。所以，最重要的其实是原型链。最需要了解的就是JS的面向对象编程了，因为它能很好的让人们了解原型及原型链。</p><p>JS使用原型链来实现面向对象编程。JS使用构造函数来构造对象，好多人喜欢把构造函数叫做类，构造函数就是个普通的函数。</p><p>为了节约书写时间，我这里直接使用类来表示构造函数（大家都懂的，JS没有类）。在讨论类之前，我先说说和函数有关的一个东西，使用函数来说比较好。JS里任何函数的定义，都会创建一个函数的伴生对象（我自己起的名），这个伴生对象就是构造新对象时的原型。这个图能很好的说明它们之间的关系:</p><p><img src="/image/JS_OOP.png" alt="JS面向对象"></p><p>图片说明：图片中new括起来的区域，是我自己想的过程，和真实的new的结果一样，这里只是为了做个说明，但不代表JS真实的new操作。</p><p>对象的方法都是函数，由于函数的复用性，所以没有必要都拥有各自的方法，但是属性是用来表示对象自身的状态的，所以各自的属性应该是独立的（不说例外情况）</p><p>基于以上，构造对象的包括工厂函数模式，构造函数模式，原型模式这里就不说了，大家都知道构造加原型模式，所以这里也不说了，都快嚼烂了。</p><p>至于好多人都说对于 protptype constructor <strong>proto</strong> 等概念混淆了，容易懵逼，这个我会在后面捋一遍。</p><p>先把继承讲了：</p><p>属性继承：</p><p>把父类拿到子类里执行，通过call apply bind，只要能改变父类this为子类this的方式都行，比如添加属性执行，在删除属性。这样的话。相当于把父类里定义的属性添加到子类里面了。没了！没什么难度！</p><p>方法继承：</p><p>方法继承说白了，就是个属性查找的事，之前我们说过，属性查找基于原型链。所以我们只要使用原型链把这些对象连接起来，就万事大吉。不过这里只有一个忠告，就是不要让任何环节中的两个我们操作的对象是一个对象。因为原则就是一个对象修改自己的属性不应该影响到其他对象的属性。只要满足上述的要求，想怎么继承就怎么继承。</p><p>这里列举几个典型的继承方式，都是平常会接触到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="comment">// 道格拉斯继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">T</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">T.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> T();</span><br><span class="line"><span class="comment">// 本质和道格拉斯继承一样</span></span><br><span class="line">Child.protptype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"><span class="comment">// 非标准API实现继承，尽量不要使用</span></span><br><span class="line">Child.prototype.__proto__ = Parent.prototype;</span><br><span class="line"><span class="comment">// 本质和 __proto__ 方式一样</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他自定义</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Parent.prototype);</span><br><span class="line">Child.prototype = obj;</span><br><span class="line"><span class="comment">// 还是那句话，只要通过对象的原型属性把原型链连接好，想怎样继承都行。</span></span><br></pre></td></tr></table></figure><p>注意点：</p><p>上述所谓的组合继承 是有缺陷的继承，因为如果Parent类需要传入参数，那我们就需要在继承的时候传入相应的参数，如果内部不做兼容处理，就会报错。但问题是，这样的继承就没有普遍性了，我们不可能每次都能传入合适的参数。所以国外的一个小伙，名叫道格拉斯，使用了一个中间类来避开这个问题，能避开的本质是，Parent 类只有在实例化的时候才会有这个问题，但中间类T不需要传参，T的实例化没有问题，也就解决问题了。</p><p>所以得出一个结论，在做继承时，满足以上我所说的要求的情况下，尽量不要使用父类的实例来做中间对象实现继承。只要避开这个，怎么样继承都行。</p><p>对于有些人觉的以下方式也没问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure><p>这种方式一看就是和我上面说的有冲突，什么冲突？不要让任何环节中的两个我们操作的对象是一个对象。因为如果你改Child.prototype上的属性，就相当于修改Parent.prototype上的属性。所以严格禁止。</p><p>有人会说了，上面的道格拉斯继承，也是两个对象是同一个对象。说的好，但问题是，道格拉斯继承的中间类T的prototype不是我们要直接操作的对象，所以无所谓。</p><p>注：这里的直接操作说的是业务需求上的操作。如果有人作死，偏要拿到这些原型对象做各种修改，那就让他作死吧。</p><p>至于ES6的class，这里就不说了，它就是个语法糖，改变了一下语法书写，对内部的一些属性做了些更严格的限制外，和ES5一样。</p><p>JS里最重要的函数和对象说完了，似乎也没什么了，其他的都是些API，只要查文档就行。我一直秉承的一个原则就是，能查API文档解决的事情就不是事。了解API体现不了一个人的实力。</p><p>JS严格模式是一种向未来兼容的方式。也都是需要记住的一些规则，但都很合理。这里我也不贴出来了，用的多了，自然就有印象了，MDN，百度，网上一大堆。</p><p>开发者自己在使用严格模式的时候，不要把 ‘use strict’ 使用在全局，只使用在自己的代码最外层函数里，因为你的代码不应该影响别人的代码，而且如果别人没使用严格模式，全局模式使用就可能会报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对JS学习过程中的一些理解和总结&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://jiankafei.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://jiankafei.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Web全链路优化</title>
    <link href="https://jiankafei.github.io/web/full-link-optimization/"/>
    <id>https://jiankafei.github.io/web/full-link-optimization/</id>
    <published>2017-11-21T03:52:15.000Z</published>
    <updated>2017-12-08T13:03:07.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从访问一个页面到页面的呈现，要经历以下的过程：<br>DNS查询-TCP连接 &gt; 客户端http请求 &gt; 服务端响应 &gt; 客户端渲染<br>下面就从整个过程分析下有哪些可以优化的地方和措施。</p><a id="more"></a><h2 id="DNS查询优化："><a href="#DNS查询优化：" class="headerlink" title="DNS查询优化："></a>DNS查询优化：</h2><p>client &gt; os &gt; hosts &gt; os发起DNS请求</p><p>DNS查询总是要经过上述过程的，不可避免。<br>可以优化的地方是前端的 DNS-Prefetch 链接预取。在页面的head头部加入：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样可以预查询DNS和预加载资源到缓存。</p><h2 id="请求速度优化："><a href="#请求速度优化：" class="headerlink" title="请求速度优化："></a>请求速度优化：</h2><h3 id="资源优化："><a href="#资源优化：" class="headerlink" title="资源优化："></a>资源优化：</h3><ol><li>对同一个域名的同类资源进行请求合并，减少http请求数，需要后端支持；</li><li>对资源进行压缩及合并处理，如果可以的话；</li><li>如果一次性加载的资源少，尽量使用一个cdn，如果加载的资源非常多，则可以启用多个cdn域名，从而突破前端连接数限制；</li><li>资源按需加载，比如在 SPA 单页应用中，如果单页应用比较大，就不要一次性加载全部资源和页面，而应该按需异步加载访问的页面组件。webpack提供了 Code Splitting 代码分割功能，Vue就使用该功能实现异步组件；</li></ol><h3 id="http协议选择："><a href="#http协议选择：" class="headerlink" title="http协议选择："></a>http协议选择：</h3><p>各大浏览器厂商都已经支持 http2了，如果可以，尽量启用 http2。http2 有很多优点：</p><ol><li>服务端推送，可以缓存；</li><li>多路复用：单连接并发多请求。基于流的实现；</li><li>头部压缩：使用 HPACK 算法压缩头部；</li><li>请求优先级和依赖性：优先级高的需要首先处理，优先级低的可以稍微排排队；</li><li>二进制文件，解析更有效率，更紧密，更不容易出错；</li></ol><h2 id="渲染优化："><a href="#渲染优化：" class="headerlink" title="渲染优化："></a>渲染优化：</h2><h3 id="script优化："><a href="#script优化：" class="headerlink" title="script优化："></a>script优化：</h3><ol><li>script标签放到body闭合标签前面，不阻塞页面渲染，加快页面显示；</li><li>永远只在必要的情况下使用框架和库，如果业务很小但是用了较大的库，即使是 jQuery 也是得不偿失的；</li><li>能异步加载和延迟加载的script就异步和延迟加载，比如统计代码；</li></ol><h3 id="css优化："><a href="#css优化：" class="headerlink" title="css优化："></a>css优化：</h3><ol><li>删除无用规则和重复规则；</li><li>可以考虑内联关键CSS；</li><li>避免@imports和Base64；<br>避免 Bas64 可以提高css文件的压缩比率；甚至在任何文件里都应该避免使用 Base64；</li><li>尽量少的使用耗性能的 css 属性和选择器，比如 * 通配符，从而加快CSSOM构建和渲染。css优化细节挺多的，这里不细说；</li><li>style标签放到head标签，防止页面的跳动渲染；</li></ol><h3 id="image优化："><a href="#image优化：" class="headerlink" title="image优化："></a>image优化：</h3><ol><li>尽量使用压缩比率高的格式，比如 webp；</li><li>对于图标，尽量使用svg或者iconfont字体图标。也可以使用兼容性较好的 css sprite；</li><li>尽量不要包含太多的 Base64 格式的图片，会降低文件压缩率；</li><li><p>如果页面有大量图片，建议做图片延迟加载和预加载；<br>在分页业务里，可以考虑使用图片预加载。<br>在一次性展示大量图片的页面里，可以考虑使用延迟加载。</p><p>注：更具体的图片优化，可以看这篇文章：<a href="http://www.cnblogs.com/wizcabbit/p/web-image-optimization.html" target="_blank" rel="noopener">图片优化</a></p></li></ol><h3 id="html优化："><a href="#html优化：" class="headerlink" title="html优化："></a>html优化：</h3><ol><li>尽量使用语义化标签，提高SEO优化；</li><li>对于不支持h5标签的浏览器采用html5.shim.js来支持；</li><li>标签不要嵌套过深；</li><li>对于移动端的响应式布局和高清显式，可以看我的原创项目<a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible</a>，该项目在生产环境下经历了多个版本，目前已经很稳定了，具体可以查看项目。</li></ol><h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><ol><li>避免不必要的重定向；</li><li>使用内容分发网络 CDN ，加快资源响应；</li><li>适当调节CDN的TTL值，增加缓存时间，提高缓存命中率；</li><li>开启 gzip 压缩；</li></ol><h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><ol><li>Last-Modified: 能初步检测文件是否更改，没更改则返回304，但是 Last-Modified 也有它自己的缺点，比如文件内容没改变，只是最后修改时间改变，还有它的检测时间是秒级的，还有它不能精确得到文件的最后修改时间，这些问题都会导致问题；</li><li>ETag：ETag可以解决Last-Modified的问题，ETag是内容相关的。所有把两者放在一起，可以很好的做到缓存优化；</li><li>Cache-Control: 用于代替 Expires，对于某些只需要在一定时间之后过期的资源来说，使用它最合适了；</li></ol><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><ol><li>服务端的其他优化，比如负载均衡等，由于尚不了解，这里就不说了；</li><li>数据库也不甚了解，这里也不说了；</li><li>哪里说的不对，可以提issue交流；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从访问一个页面到页面的呈现，要经历以下的过程：&lt;br&gt;DNS查询-TCP连接 &amp;gt; 客户端http请求 &amp;gt; 服务端响应 &amp;gt; 客户端渲染&lt;br&gt;下面就从整个过程分析下有哪些可以优化的地方和措施。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://jiankafei.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://jiankafei.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>flex布局解析</title>
    <link href="https://jiankafei.github.io/css/flex-layout/"/>
    <id>https://jiankafei.github.io/css/flex-layout/</id>
    <published>2016-08-12T00:15:29.000Z</published>
    <updated>2017-12-08T13:02:25.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。<br><a id="more"></a></p><h2 id="看法"><a href="#看法" class="headerlink" title="看法"></a>看法</h2><p>这里我只说说最新版本，在我看来，学习即将不再使用的东西是对时间和精力的浪费(个人观点，不喜勿喷)，旧的东西大家如果想了解可以度娘。虽然我不说旧版本，但我还是会给出完整的兼容实现。具体见我的这个项目<a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible</a>的flexbox.css。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="flexbox盒模型"><a href="#flexbox盒模型" class="headerlink" title="flexbox盒模型"></a>flexbox盒模型</h3><p>该盒模型，你只需知道有主轴和侧轴之分就行，没有横轴和竖轴或者水平和垂直之说。<br>那怎么区分主轴和侧轴呢，见下方。</p><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><p>一句话，该属性设置的方向就是主轴，和主轴垂直的方向那就是侧轴了。<br>这里需要说一点，就是每一个轴都有两个方向。默认从左到右，从上到下，标准的坐标系。<br>现在主轴和侧轴都确定了，但如果内容比较多，你想让它换行，怎么办呢，不急，看下面。</p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap：nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure><p>该属性就是 flex 盒模型里的换行属性。三个值我就不解释了，自己查单词去。<br>既然有了换行，那就说明会有多行，如果有个场景需要让多行的元素块在定高的盒子里上下居中，怎么办呢，很显然这说的时对齐方式了。看下面。</p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>主轴对齐方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content：flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure></p><p>这个真没什么可解释的</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>侧轴对齐方式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content：flex-start | flex-end | center | space-between | space-around | stretch</span><br></pre></td></tr></table></figure></p><p>这里唯一需要说的就是 stretch<br>stretch 的作用是，在侧轴间距上，将各行均匀伸展来撑满真个侧轴间距。具体分两种情况。<br>如果剩余的空间是负数，该值等效于’flex-start’；<br>在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。</p><p>在侧轴的对齐上，align-content 只解决了把侧轴里多行看成整体在盒子内的对齐；<br>而侧轴里的每一行上元素的高度不一定是一致的，有的高有的低，该行的行高肯定就是最高元素的高度了。这里我们称为行内轴，有些场景就需要在一行里这些元素是如何对齐的，也就是在行内轴上是如何对齐的，这有点像 vertical-align（只是有点像，不要混为一谈）。是在本行内开始位置对齐，还是中部对齐，还是结束对齐等等（由flex-direction决定哪里是开始位置）</p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items：flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure><p>这里说下 baseline<br>    如果弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</p><p>还有 stretch<br>    会遵照’min/max-width/height’属性的限制</p><p>到现在，侧轴和行内轴的对齐都解决了，但有些人说行内轴对齐好了，但我想让一行中的某一个元素的对齐方式和其他的元素不一样，该怎么办呢，看下面。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self：auto | flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure><p>这个属性的值和上一个的一模一样，是对行内轴对齐方式的复写，但是只应用在子元素上，从而单独复写对齐方式。</p><p>ok，现在换行，对齐，子元素单独对齐都好了，那为什么还叫伸缩盒模型呢，那是因为下面。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>这个属性其实是个简写属性，具体是 flex-grow flex-shrink flex-basis 的简写属性</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>扩展比率，默认 0<br>没什么可说的，就是个数学问题</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>收缩比率，不允许负值，默认 1<br>没什么可说的，就是个数学问题</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | &lt;percentage&gt; | auto | content</span><br></pre></td></tr></table></figure><p>基准宽度，就是说在此宽度的基础上扩展或收缩宽度<br>这里说下 auto： 无特定宽度值，取决于其它属性值<br>还有 content：基于内容自动计算宽度</p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>和它的名字一样，掌管盒子内子元素的流动，就和水一样，流向哪个方向，遇到石头是冲过去还是拐弯，都是这个属性的事情。<br>废话不说了，该属性也是个简写属性，是 flex-direction 和 flex-wrap 的简写属性。没了。</p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>记得小时候每次开学，都会有一次排队选座位的经历，老师显然大家自觉排好，然后老师再仔细看一遍，把没排好同学互换过来，然后分座位。排队很简单，错了可以再排，但如果时html元素呢，如果我们把元素的顺序都写好了， 在没有定位，浮动，js操作的情况下，元素肯定是按顺序排列的，如果我们想互换元素之间的顺序，是做不到的。那如果有这样的需求怎么办呢。这就要order上场了，首先 display: flex 搭好台子，order就可以表演了。通过对flex子元素设置order属性，可以改变元素原来的显示顺序。当然它也受 flex-direction 的影响。<br>具体规则是：<br>用整数值来定义排列顺序，数值小的排在前面。可以为负值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://jiankafei.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jiankafei.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端web高清屏显示及伸缩布局方案(原创)</title>
    <link href="https://jiankafei.github.io/js/flexible/"/>
    <id>https://jiankafei.github.io/js/flexible/</id>
    <published>2016-08-11T02:41:29.000Z</published>
    <updated>2017-12-08T12:46:20.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统；</p><a id="more"></a><p>这个方案我是在网上看了关于 viewport 缩放页面后，结合当前使用的rem布局方案而来。<br>你有没有在移动H5开发的时候遇到过这样的情况，页面不清晰，明明1px的线条看上去却很宽，而且有些模糊，图片看上去好像失真了一样？和大厂的m站一比，光看自己页面的细节就土的掉渣。遇到过，那就说明你用的移动设备的屏幕是高清屏，也就是dpr大于1的屏幕。而这一切都是拜 乔帮主(你知道是哪位) 所赐。我这里只是简单的介绍，本来也想详细的说说，但感觉自己的语言组织不是太给力，所以还是推荐大家直接看参考文章，这些文章都很值得大家好好看的，里面图文并茂，该有的不该有的都有。</p><h2 id="传统的一种移动端布局方案"><a href="#传统的一种移动端布局方案" class="headerlink" title="传统的一种移动端布局方案"></a>传统的一种移动端布局方案</h2><p>w: 当前页面宽度<br>x: 当前字体大小</p><p>换算关系:<br>w / 640 = x / 100</p><p>所有的px尺寸都除以100，就得到rem的尺寸</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><pre><code>border: 1px问题;图片高清问题;屏幕适配布局问题;</code></pre><h2 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h2><h3 id="设备像素比dpr"><a href="#设备像素比dpr" class="headerlink" title="设备像素比dpr"></a>设备像素比dpr</h3><pre><code>dpr = 物理像素 / 设备独立像素;</code></pre><p>参考文章：<br><a href="http://www.zhangxinxu.com/wordpress/?p=2568" target="_blank" rel="noopener">设备像素比devicePixelRatio简单介绍</a><br><a href="http://sentsin.com/web/1212.html" target="_blank" rel="noopener">原创移动端高清、多屏适配方案</a></p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>关于flex布局可以看下我的这篇文章：<a href="https://jiankafei.github.io/css/flexLayout/">flex布局解析</a></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="flex解决布局适配问题"><a href="#flex解决布局适配问题" class="headerlink" title="flex解决布局适配问题"></a>flex解决布局适配问题</h3><p>参见 <a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible项目</a> 的flexible.css</p><h3 id="动态修改meta标签实现页面的缩放"><a href="#动态修改meta标签实现页面的缩放" class="headerlink" title="动态修改meta标签实现页面的缩放"></a>动态修改meta标签实现页面的缩放</h3><p>参见 <a href="https://github.com/jiankafei/flexible" target="_blank" rel="noopener">flexible项目</a> 的flexible.js</p><h3 id="高清图片"><a href="#高清图片" class="headerlink" title="高清图片"></a>高清图片</h3><h4 id="SVG-图标系统"><a href="#SVG-图标系统" class="headerlink" title="SVG 图标系统"></a>SVG 图标系统</h4><p>可以解决小icon的高清适配问题，因为SVG是矢量图，缩放不会失真;<br>建议通过 <a href="http://www.iconfont.cn/plus" target="_blank" rel="noopener">iconfont</a> 制作<br>这里有一个在线的 <a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="noopener">svg压缩工具</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 定义 */</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">symbol</span> <span class="attr">id</span>=<span class="string">"icon"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 200 200"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>opt<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* 使用 */</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h4><p>可以解决 <code>icon</code> 的高清适配问题，建议通过 <a href="http://www.iconfont.cn/plus" target="_blank" rel="noopener">iconfont</a> 制作</p><h4 id="MediaQuery"><a href="#MediaQuery" class="headerlink" title="MediaQuery"></a>MediaQuery</h4><p><code>MediaQuery</code> 可以解决背景图片的高清适配;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen</span><br><span class="line">and (-webkit-device-pixel-ratio:<span class="number">2</span>)</span><br><span class="line">and (-webkit-min-device-pixel-ratio:<span class="number">1.5</span>)</span><br><span class="line">and (-webkit-max-device-pixel-ratio:<span class="number">2.5</span>)&#123;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(<span class="selector-tag">icon_2</span>@.<span class="keyword">png</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CSS的image-set属性"><a href="#CSS的image-set属性" class="headerlink" title="CSS的image-set属性"></a>CSS的image-set属性</h4><p>image-set属性可以解决背景图片的高清适配;<br>目前移动端可以使用带 -webkit- 前缀的属性，Android4.4及以上系统，IOS9.0及以上系统;<br>可在 <a href="http://www.caniuse.com/#search=image-set" target="_blank" rel="noopener">caniuse</a> 查看该属性目前的支持情况;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="comment">/* 不支持image-set的浏览器 */</span></span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(icon_1@.png) no-repeat;</span><br><span class="line"><span class="comment">/* 支持image-set的浏览器 */</span></span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-image-set</span>(</span><br><span class="line">url(icon_1@.png) <span class="number">1</span>x, <span class="comment">/* 普通屏 */</span></span><br><span class="line"><span class="built_in">url</span>(icon_2@.png) <span class="number">2</span>x <span class="comment">/* 高清屏 */</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片延迟加载"><a href="#图片延迟加载" class="headerlink" title="图片延迟加载"></a>图片延迟加载</h4><p>移动端的图片延迟加载在我看来很必要的，而且顺带可以解决图片的高清适配;<br>通过 <code>window.devicePixelRatio</code> 可以获取到当前设备的dpr，然后加载相应的图片。</p><h4 id="img的srcset和sizes属性"><a href="#img的srcset和sizes属性" class="headerlink" title="img的srcset和sizes属性"></a>img的srcset和sizes属性</h4><p><img src="" srcset="" sizes=""><br>解决图片的高清适配，具体还是看<a href="http://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/" target="_blank" rel="noopener">张鑫旭张老师的这篇文章</a></p><p>转载请注明出处：<a href="https://jiankafei.github.io/js/flexible/">移动端web高清屏显示及伸缩布局方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统；&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiankafei.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jiankafei.github.io/tags/js/"/>
    
  </entry>
  
</feed>
