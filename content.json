{"meta":{"title":"Zr的博客","subtitle":"向死而生","description":"王勒的个人博客 Zr的个人博客","author":"王勒","url":"https://jiankafei.github.io"},"pages":[{"title":"","date":"2017-11-21T07:46:53.528Z","updated":"2017-11-21T07:05:10.994Z","comments":true,"path":"404.html","permalink":"https://jiankafei.github.io/404.html","excerpt":"","text":"404"},{"title":"About","date":"2017-11-21T08:44:18.308Z","updated":"2017-11-21T08:44:18.308Z","comments":true,"path":"about/index.html","permalink":"https://jiankafei.github.io/about/index.html","excerpt":"","text":"关于我"},{"title":"Categories","date":"2017-11-21T08:43:24.570Z","updated":"2017-11-21T08:43:24.570Z","comments":true,"path":"categories/index.html","permalink":"https://jiankafei.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-21T08:43:41.973Z","updated":"2017-11-21T08:43:41.973Z","comments":true,"path":"tags/index.html","permalink":"https://jiankafei.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Web全链路优化","slug":"Web全链路优化","date":"2017-11-21T03:52:15.000Z","updated":"2017-11-21T04:45:54.608Z","comments":false,"path":"web/Full link optimization at the front end/","link":"","permalink":"https://jiankafei.github.io/web/Full link optimization at the front end/","excerpt":"前言从访问一个页面到页面的呈现，要经历以下的过程：DNS查询-TCP连接 &gt; 客户端http请求 &gt; 服务端响应 &gt; 客户端渲染下面就从整个过程分析下有哪些可以优化的地方和措施。","text":"前言从访问一个页面到页面的呈现，要经历以下的过程：DNS查询-TCP连接 &gt; 客户端http请求 &gt; 服务端响应 &gt; 客户端渲染下面就从整个过程分析下有哪些可以优化的地方和措施。 DNS查询优化：client &gt; os &gt; hosts &gt; os发起DNS请求 DNS查询总是要经过上述过程的，不可避免。可以优化的地方是前端的 DNS-Prefetch 链接预取。在页面的head头部加入：1&lt;link ref=\"prefetch\" href=\"\"&gt; 这样可以预查询DNS和预加载资源到缓存。 请求速度优化：资源优化： 对同一个域名的同类资源进行请求合并，减少http请求数，需要后端支持； 对资源进行压缩及合并处理，如果可以的话； 如果一次性加载的资源少，尽量使用一个cdn，如果加载的资源非常多，则可以启用多个cdn域名，从而突破前端连接数限制； 资源按需加载，比如在 SPA 单页应用中，如果单页应用比较大，就不要一次性加载全部资源和页面，而应该按需异步加载访问的页面组件。webpack提供了 Code Splitting 代码分割功能，Vue就使用该功能实现异步组件； http协议选择：各大浏览器厂商都已经支持 http2了，如果可以，尽量启用 http2。http2 有很多优点： 服务端推送，可以缓存； 多路复用：单连接并发多请求。基于流的实现； 头部压缩：使用 HPACK 算法压缩头部； 请求优先级和依赖性：优先级高的需要首先处理，优先级低的可以稍微排排队； 二进制文件，解析更有效率，更紧密，更不容易出错； 渲染优化：script优化： script标签放到body闭合标签前面，不阻塞页面渲染，加快页面显示； 永远只在必要的情况下使用框架和库，如果业务很小但是用了较大的库，即使是 jQuery 也是得不偿失的； 能异步加载和延迟加载的script就异步和延迟加载，比如统计代码； css优化： 删除无用规则和重复规则； 可以考虑内联关键CSS； 避免@imports和Base64；避免 Bas64 可以提高css文件的压缩比率；甚至在任何文件里都应该避免使用 Base64； 尽量少的使用耗性能的 css 属性和选择器，比如 * 通配符，从而加快CSSOM构建和渲染。css优化细节挺多的，这里不细说； style标签放到head标签，防止页面的跳动渲染； image优化： 尽量使用压缩比率高的格式，比如 webp； 对于图标，尽量使用svg或者iconfont字体图标。也可以使用兼容性较好的 css sprite； 尽量不要包含太多的 Base64 格式的图片，会降低文件压缩率； 如果页面有大量图片，建议做图片延迟加载和预加载；在分页业务里，可以考虑使用图片预加载。在一次性展示大量图片的页面里，可以考虑使用延迟加载。 注：更具体的图片优化，可以看这篇文章：图片优化 html优化： 尽量使用语义化标签，提高SEO优化； 对于不支持h5标签的浏览器采用html5.shim.js来支持； 标签不要嵌套过深； 对于移动端的响应式布局和高清显式，可以看我的原创项目flexible，该项目在生产环境下经历了多个版本，目前已经很稳定了，具体可以查看项目。 服务端： 避免不必要的重定向； 可以适当提高最大连接数，加快资源响应； 使用内容分发网络 CDN ，加快资源响应； 适当调节CDN的TTL值，增加缓存时间，提高缓存命中率； 开启 gzip 压缩； 缓存优化： Last-Modified: 能初步检测文件是否更改，没更改则返回304，但是 Last-Modified 也有它自己的缺点，比如文件内容没改变，只是最后修改时间改变，还有它的检测时间是秒级的，还有它不能精确得到文件的最后修改时间，这些问题都会导致问题； ETag：ETag可以解决Last-Modified的问题，ETag是内容相关的。所有把两者放在一起，可以很好的做到缓存优化； Cache-Control: 用于代替 Expires，对于某些只需要在一定时间之后过期的资源来说，使用它最合适了； 其他： 服务端的其他优化，比如负载均衡等，由于尚不了解，这里就不说了； 数据库也不甚了解，这里也不说了； 哪里说的不对，可以提issue交流；","categories":[{"name":"web","slug":"web","permalink":"https://jiankafei.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://jiankafei.github.io/tags/web/"}]},{"title":"flex布局解析","slug":"flex布局解析","date":"2016-08-12T00:15:29.000Z","updated":"2017-04-10T10:42:44.165Z","comments":false,"path":"css/flexLayout/","link":"","permalink":"https://jiankafei.github.io/css/flexLayout/","excerpt":"前言flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。","text":"前言flexbox的发展还是比较曲折的，总共经历了三个版本，旧版本，过度版本，新版本。想想都可怕。这是我在学习flexbox盒模型后，对它的理解，希望能解决初学者在学习flexbox时遇到的概念陷阱，帮助初学者很好的理解和学习flexbox。 看法这里我只说说最新版本，在我看来，学习即将不再使用的东西是对时间和精力的浪费(个人观点，不喜勿喷)，旧的东西大家如果想了解可以度娘。虽然我不说旧版本，但我还是会给出完整的兼容实现。具体见我的这个项目flexible的flexbox.css。 正题flexbox盒模型该盒模型，你只需知道有主轴和侧轴之分就行，没有横轴和竖轴或者水平和垂直之说。那怎么区分主轴和侧轴呢，见下方。 flex-direction1flex-direction: row | row-reverse | column | column-reverse 一句话，该属性设置的方向就是主轴，和主轴垂直的方向那就是侧轴了。这里需要说一点，就是每一个轴都有两个方向。默认从左到右，从上到下，标准的坐标系。现在主轴和侧轴都确定了，但如果内容比较多，你想让它换行，怎么办呢，不急，看下面。 flex-wrap1flex-wrap：nowrap | wrap | wrap-reverse 该属性就是 flex 盒模型里的换行属性。三个值我就不解释了，自己查单词去。既然有了换行，那就说明会有多行，如果有个场景需要让多行的元素块在定高的盒子里上下居中，怎么办呢，很显然这说的时对齐方式了。看下面。 justify-content主轴对齐方式1justify-content：flex-start | flex-end | center | space-between | space-around 这个真没什么可解释的 align-content侧轴对齐方式1align-content：flex-start | flex-end | center | space-between | space-around | stretch 这里唯一需要说的就是 stretchstretch 的作用是，在侧轴间距上，将各行均匀伸展来撑满真个侧轴间距。具体分两种情况。如果剩余的空间是负数，该值等效于’flex-start’；在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。 在侧轴的对齐上，align-content 只解决了把侧轴里多行看成整体在盒子内的对齐；而侧轴里的每一行上元素的高度不一定是一致的，有的高有的低，该行的行高肯定就是最高元素的高度了。这里我们称为行内轴，有些场景就需要在一行里这些元素是如何对齐的，也就是在行内轴上是如何对齐的，这有点像 vertical-align（只是有点像，不要混为一谈）。是在本行内开始位置对齐，还是中部对齐，还是结束对齐等等（由flex-direction决定哪里是开始位置） align-items1align-items：flex-start | flex-end | center | baseline | stretch 这里说下 baseline 如果弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 还有 stretch 会遵照’min/max-width/height’属性的限制 到现在，侧轴和行内轴的对齐都解决了，但有些人说行内轴对齐好了，但我想让一行中的某一个元素的对齐方式和其他的元素不一样，该怎么办呢，看下面。 align-self1align-self：auto | flex-start | flex-end | center | baseline | stretch 这个属性的值和上一个的一模一样，是对行内轴对齐方式的复写，但是只应用在子元素上，从而单独复写对齐方式。 ok，现在换行，对齐，子元素单独对齐都好了，那为什么还叫伸缩盒模型呢，那是因为下面。 flex这个属性其实是个简写属性，具体是 flex-grow flex-shrink flex-basis 的简写属性 flex-grow扩展比率，默认 0没什么可说的，就是个数学问题 flex-shrink收缩比率，不允许负值，默认 1没什么可说的，就是个数学问题 flex-basis1flex-basis: &lt;length&gt; | &lt;percentage&gt; | auto | content 基准宽度，就是说在此宽度的基础上扩展或收缩宽度这里说下 auto： 无特定宽度值，取决于其它属性值还有 content：基于内容自动计算宽度 flex-flow和它的名字一样，掌管盒子内子元素的流动，就和水一样，流向哪个方向，遇到石头是冲过去还是拐弯，都是这个属性的事情。废话不说了，该属性也是个简写属性，是 flex-direction 和 flex-wrap 的简写属性。没了。 order记得小时候每次开学，都会有一次排队选座位的经历，老师显然大家自觉排好，然后老师再仔细看一遍，把没排好同学互换过来，然后分座位。排队很简单，错了可以再排，但如果时html元素呢，如果我们把元素的顺序都写好了， 在没有定位，浮动，js操作的情况下，元素肯定是按顺序排列的，如果我们想互换元素之间的顺序，是做不到的。那如果有这样的需求怎么办呢。这就要order上场了，首先 display: flex 搭好台子，order就可以表演了。通过对flex子元素设置order属性，可以改变元素原来的显示顺序。当然它也受 flex-direction 的影响。具体规则是：用整数值来定义排列顺序，数值小的排在前面。可以为负值。","categories":[{"name":"css","slug":"css","permalink":"https://jiankafei.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jiankafei.github.io/tags/css/"}]},{"title":"移动端web高清屏显示及伸缩布局方案(原创)","slug":"移动端web高清屏显示及伸缩布局方案","date":"2016-08-11T02:41:29.000Z","updated":"2017-11-21T04:25:00.920Z","comments":false,"path":"js/flexible/","link":"","permalink":"https://jiankafei.github.io/js/flexible/","excerpt":"前言该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统；","text":"前言该解决方案包含的技术有：传统的rem移动端布局；动态修改meta标签实现不同dpr设备的页面缩放；flex弹性布局；媒体查询加载相应倍图；Img的srcset；background的image-set；svg图标系统； 这个方案我是在网上看了关于 viewport 缩放页面后，结合当前使用的rem布局方案而来。你有没有在移动H5开发的时候遇到过这样的情况，页面不清晰，明明1px的线条看上去却很宽，而且有些模糊，图片看上去好像失真了一样？和大厂的m站一比，光看自己页面的细节就土的掉渣。遇到过，那就说明你用的移动设备的屏幕是高清屏，也就是dpr大于1的屏幕。而这一切都是拜 乔帮主(你知道是哪位) 所赐。我这里只是简单的介绍，本来也想详细的说说，但感觉自己的语言组织不是太给力，所以还是推荐大家直接看参考文章，这些文章都很值得大家好好看的，里面图文并茂，该有的不该有的都有。 传统的一种移动端布局方案w: 当前页面宽度x: 当前字体大小 换算关系:w / 640 = x / 100 所有的px尺寸都除以100，就得到rem的尺寸 解决什么问题border: 1px问题; 图片高清问题; 屏幕适配布局问题; 用到的知识点设备像素比dprdpr = 物理像素 / 设备独立像素; 参考文章：设备像素比devicePixelRatio简单介绍原创移动端高清、多屏适配方案 viewport flex布局关于flex布局可以看下我的这篇文章：flex布局解析 解决思路flex解决布局适配问题参见 flexible项目 的flexible.css 动态修改meta标签实现页面的缩放参见 flexible项目 的flexible.js 高清图片SVG 图标系统可以解决小icon的高清适配问题，因为SVG是矢量图，缩放不会失真;建议通过 iconfont 制作这里有一个在线的 svg压缩工具 123456789101112/* 定义 */&lt;svg style=\"display: none\"&gt; &lt;symbol id=\"icon\" viewBox=\"0 0 200 200\"&gt; &lt;title&gt;opt&lt;/title&gt; &lt;path d=\"\" /&gt; &lt;/symbol&gt;&lt;/svg&gt;/* 使用 */&lt;svg&gt; &lt;use xlink:href=\"#icon\"&gt;&lt;/use&gt;&lt;/svg&gt; iconfont可以解决 icon 的高清适配问题，建议通过 iconfont 制作 MediaQueryMediaQuery 可以解决背景图片的高清适配; 123456@media only screenand (-webkit-device-pixel-ratio:2)and (-webkit-min-device-pixel-ratio:1.5)and (-webkit-max-device-pixel-ratio:2.5)&#123; background: url(icon_2@.png) no-repeat;&#125; CSS的image-set属性image-set属性可以解决背景图片的高清适配;目前移动端可以使用带 -webkit- 前缀的属性，Android4.4及以上系统，IOS9.0及以上系统;可在 caniuse 查看该属性目前的支持情况; 123456789div&#123; /* 不支持image-set的浏览器 */ background: url(icon_1@.png) no-repeat; /* 支持image-set的浏览器 */ background: -webkit-image-set( url(icon_1@.png) 1x, /* 普通屏 */ url(icon_2@.png) 2x /* 高清屏 */ );&#125; 图片延迟加载移动端的图片延迟加载在我看来很必要的，而且顺带可以解决图片的高清适配;通过 window.devicePixelRatio 可以获取到当前设备的dpr，然后加载相应的图片。 img的srcset和sizes属性解决图片的高清适配，具体还是看张鑫旭张老师的这篇文章 转载请注明出处：移动端web高清屏显示及伸缩布局方案","categories":[{"name":"js","slug":"js","permalink":"https://jiankafei.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://jiankafei.github.io/tags/js/"}]}]}